<section>
  <h2>Why GraphQL is a language of digital transformation</h2>
  <p>GraphQL activates your mutations and changes the way you deliver solutions In the digital era, APIs are everywhere: we
    consume APIs, we produce APIs. SOAP, HTTP-RPC and REST technologies have built a new space of applicative infrastructure
    by providing connection points between platforms, apps and devices. But the density of services and the pace of delivering
    new features and updates are so important that we are continuously looking for smarter ways to expose and use APIs. GraphQL
    is a breakthrough in API design and technology to create a new generation of apps that address the challenges of the
    digital transformation wave. Transparency Apps are designed to cover a set of scenarios envisioned at a single moment
    in time. We can observe that more and more, an application is just an entry point to discover (and to hack) the API behind
    it, meaning that an application is but a frontend that reveals the potentiality of the inherent technologies exposed
    by the API. This potentiality is what businesses want to explore and ultimately incorporate to deliver their own solutions;
    it goes beyond a composite approach mixing services and features. Transformation is about transparency: to transparently
    inject our technologies into other ones, to create “unpredictable” applications. GraphQL represents a significant step
    forward in this direction, since it’s a language to perform queries and mutations in a highly customized and fluid manner.
    It allows an API user to develop a singularity, which is one of the most important qualities needed to survive digital
    transformation. Indeed, using the same APIs with the same methods tends to deliver the same kind of user experiences,
    performance and features. With its semantic approach, though, GraphQL lets you create your own story. Obviously, not
    all GraphQL APIs are equal when it comes to allowing this level of integration, and the quality of schema design and
    its implementation are critical. A schema interprets a vision into an API. A GraphQL schema defines a scope with types,
    relations, and possible queries and mutations. The GraphQL schema also reflects the technological constraints you need
    to manage, with some compromises to its design. With new advances in bots and AI, GraphQL is going to be your main frontend.
    We can already see orchestration engines for REST (such as Zapier), and it won’t be long before we see bots speaking
    GraphQL natively. GraphQL-speaking bots will unleash conversational experiences as well as also bot-to-bot communication.
    How many APIs already include the concepts of users, activities and projects? A semantic approach to API design paves
    the way to an organic integration of a universe of schemas. Perception process “Digital transformation” is the buzzword
    these days. Creating new tools and developing a collective intelligence are not new, but we have to define a tag for
    the mutations we observe in our environment. “Digital” is the magic word to identify a technological solution for the
    transformations that businesses and organizations need to address. But the challenge is less to digitize processes and
    products that change our perception; the way we see problems determines the solution that will be engaged. GraphQL contributes
    to changing our perception of API design, integration points and frontend developments. It also modifies teamwork, productivity
    and communication between parties. Changing the way we create and consume APIs will impact the nature of the features
    and experiences we deliver. Flows Finally, a transformation generates another transformation in the environment, so it’s
    probably more appropriate to talk about “continuous transformation”, meaning that transformation is actually a flow of
    changes. In the API world, changes are versions, and versioning is one of the biggest issues that needs to be managed
    when delivering and using APIs. GraphQL promises to resolve this by eliminating the need to manage versions by using
    schema deprecation features instead. This sounds fantastic, but case by case, we’ll see if this solution can cover all
    of the kinds of changes that can occur in API design and associated behaviors. A greater frequency of change is related
    to data returned by an API. Digital transformation is in fact also a modification in the temporal sense, since fresh
    updates or new data need to be pushed in real time to subscribers that can be humans, devices or bots. This real-time
    flow of information updates has to be exposed by backend services, so event APIs and real-time APIs are often provided
    in addition to REST web services. With GraphQL subscriptions, these real-time updates are available through the same
    GraphQL API and schema. This modern approach offers a fluid integration of real-time changes with a single API. Conclusion
    By nature, languages improve the quality and the fluidity of human, and now digital, exchanges. We need more automation,
    more semantics, more intelligence and more transparency to address the flow of mutations in our ecosystems and to preserve
    our singularity. GraphQL lets us write a new chapter in API design history with its graph approach and its semantic application
    possibilities. Combined with advances in AI, GraphQL might also be quickly adopted by bots…
  </p>
</section>
